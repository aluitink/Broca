@using Broca.ActivityPub.Core.Interfaces
@using KristofferStrube.ActivityStreams
@using Microsoft.AspNetCore.Components.Web.Virtualization
@typeparam TItem
@inject IActivityPubClient Client
@implements IDisposable

<div class="activitypub-collection-loader @CssClass">
    @if (CollectionUrl != null)
    {
        @if (UseVirtualization)
        {
            <Virtualize @ref="virtualizeComponent" 
                        ItemsProvider="LoadItemsAsync" 
                        ItemSize="ItemSize"
                        OverscanCount="OverscanCount">
                <ItemContent Context="item">
                    @if (ItemTemplate != null)
                    {
                        @ItemTemplate(item)
                    }
                    else
                    {
                        <div class="collection-item">@item?.ToString()</div>
                    }
                </ItemContent>
                <Placeholder>
                    @if (LoadingTemplate != null)
                    {
                        @LoadingTemplate
                    }
                    else
                    {
                        <div class="loading-placeholder">Loading...</div>
                    }
                </Placeholder>
                <EmptyContent>
                    @if (EmptyTemplate != null)
                    {
                        @EmptyTemplate
                    }
                    else
                    {
                        <div class="empty-content">No items found</div>
                    }
                </EmptyContent>
            </Virtualize>
        }
        else
        {
            @if (isLoading && !items.Any())
            {
                @if (LoadingTemplate != null)
                {
                    @LoadingTemplate
                }
                else
                {
                    <div class="loading">Loading items...</div>
                }
            }

            @if (items.Any())
            {
                <div class="collection-items">
                    @foreach (var item in items)
                    {
                        <div class="collection-item-wrapper">
                            @if (ItemTemplate != null)
                            {
                                @ItemTemplate(item)
                            }
                            else
                            {
                                <div class="collection-item">@item?.ToString()</div>
                            }
                        </div>
                    }
                </div>

                @if (hasMore)
                {
                    <div class="load-more">
                        <button @onclick="LoadMoreAsync" disabled="@isLoading" class="load-more-button">
                            @if (isLoading)
                            {
                                <span>Loading...</span>
                            }
                            else
                            {
                                <span>Load More</span>
                            }
                        </button>
                    </div>
                }
            }
            else if (!isLoading)
            {
                @if (EmptyTemplate != null)
                {
                    @EmptyTemplate
                }
                else
                {
                    <div class="empty-content">No items found</div>
                }
            }
        }

        @if (error != null && ErrorTemplate != null)
        {
            @ErrorTemplate(error)
        }
    }
</div>

@code {
    private List<TItem> items = new();
    private HashSet<string> loadedItemIds = new();
    private bool isLoading;
    private bool hasMore = true;
    private string? error;
    private Virtualize<TItem>? virtualizeComponent;
    private Dictionary<string, List<TItem>> cache = new();
    private string? lastLoadedCollectionUrl;
    private CancellationTokenSource? loadCancellation;

    /// <summary>
    /// Gets or sets the collection URL to load items from.
    /// </summary>
    [Parameter]
    public Uri? CollectionUrl { get; set; }

    /// <summary>
    /// Gets or sets the page size for loading items.
    /// </summary>
    [Parameter]
    public int PageSize { get; set; } = 20;

    /// <summary>
    /// Gets or sets whether to use virtualization for rendering.
    /// </summary>
    [Parameter]
    public bool UseVirtualization { get; set; } = true;

    /// <summary>
    /// Gets or sets whether to enable caching of loaded items.
    /// </summary>
    [Parameter]
    public bool EnableCaching { get; set; } = true;

    /// <summary>
    /// Gets or sets the item size for virtualization (in pixels).
    /// </summary>
    [Parameter]
    public float ItemSize { get; set; } = 100f;

    /// <summary>
    /// Gets or sets the overscan count for virtualization.
    /// </summary>
    [Parameter]
    public int OverscanCount { get; set; } = 3;

    /// <summary>
    /// Gets or sets the CSS class for the container.
    /// </summary>
    [Parameter]
    public string? CssClass { get; set; }

    /// <summary>
    /// Gets or sets the template for rendering items.
    /// </summary>
    [Parameter]
    public RenderFragment<TItem>? ItemTemplate { get; set; }

    /// <summary>
    /// Gets or sets the loading template.
    /// </summary>
    [Parameter]
    public RenderFragment? LoadingTemplate { get; set; }

    /// <summary>
    /// Gets or sets the empty state template.
    /// </summary>
    [Parameter]
    public RenderFragment? EmptyTemplate { get; set; }

    /// <summary>
    /// Gets or sets the error template.
    /// </summary>
    [Parameter]
    public RenderFragment<string>? ErrorTemplate { get; set; }

    /// <summary>
    /// Gets or sets a callback for when items are loaded.
    /// </summary>
    [Parameter]
    public EventCallback<IEnumerable<TItem>> OnItemsLoaded { get; set; }

    protected override async Task OnParametersSetAsync()
    {
        // Check if collection URL changed
        if (CollectionUrl?.ToString() != lastLoadedCollectionUrl)
        {
            lastLoadedCollectionUrl = CollectionUrl?.ToString();
            
            // Cancel any ongoing loads
            loadCancellation?.Cancel();
            loadCancellation = new CancellationTokenSource();
            
            // Try to load from cache first
            if (EnableCaching && CollectionUrl != null && cache.TryGetValue(CollectionUrl.ToString(), out var cachedItems))
            {
                items = new List<TItem>(cachedItems);
                RebuildIdSet();
                hasMore = cachedItems.Count >= PageSize;
                StateHasChanged();
            }
            else if (CollectionUrl != null && !UseVirtualization)
            {
                await LoadInitialItemsAsync();
            }
        }
    }

    private void RebuildIdSet()
    {
        loadedItemIds.Clear();
        foreach (var item in items)
        {
            var id = GetItemId(item);
            if (!string.IsNullOrEmpty(id))
            {
                loadedItemIds.Add(id);
            }
        }
    }

    private string? GetItemId(TItem item)
    {
        if (item == null) return null;

        // Try to get ID from common ActivityStreams properties
        var type = item.GetType();
        var idProperty = type.GetProperty("Id");
        if (idProperty != null && idProperty.PropertyType == typeof(string))
        {
            return idProperty.GetValue(item) as string;
        }

        return null;
    }

    private bool ShouldIncludeItem(TItem item)
    {
        var id = GetItemId(item);
        if (string.IsNullOrEmpty(id))
        {
            // If no ID, include the item (can't deduplicate)
            return true;
        }

        return !loadedItemIds.Contains(id);
    }

    private void AddItemWithTracking(TItem item)
    {
        items.Add(item);
        var id = GetItemId(item);
        if (!string.IsNullOrEmpty(id))
        {
            loadedItemIds.Add(id);
        }
    }

    private async Task LoadInitialItemsAsync()
    {
        if (isLoading || CollectionUrl == null) return;

        isLoading = true;
        error = null;
        items.Clear();
        loadedItemIds.Clear();
        StateHasChanged();

        try
        {
            var loadedItems = new List<TItem>();
            await foreach (var item in Client.GetCollectionAsync<TItem>(CollectionUrl!, PageSize))
            {
                if (loadCancellation?.Token.IsCancellationRequested == true)
                {
                    return;
                }

                if (ShouldIncludeItem(item))
                {
                    loadedItems.Add(item);
                    var id = GetItemId(item);
                    if (!string.IsNullOrEmpty(id))
                    {
                        loadedItemIds.Add(id);
                    }
                }

                if (loadedItems.Count >= PageSize)
                {
                    break;
                }
            }

            items = loadedItems;
            hasMore = loadedItems.Count >= PageSize;

            // Cache the loaded items
            if (EnableCaching && CollectionUrl != null)
            {
                cache[CollectionUrl.ToString()] = new List<TItem>(loadedItems);
            }

            if (OnItemsLoaded.HasDelegate)
            {
                await OnItemsLoaded.InvokeAsync(items);
            }
        }
        catch (OperationCanceledException)
        {
            // Load was cancelled, this is expected
        }
        catch (Exception ex)
        {
            error = $"Failed to load items: {ex.Message}";
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task LoadMoreAsync()
    {
        if (isLoading || !hasMore) return;

        isLoading = true;
        StateHasChanged();

        try
        {
            var skip = items.Count;
            var loadedItems = new List<TItem>();
            
            await foreach (var item in Client.GetCollectionAsync<TItem>(CollectionUrl!, null))
            {
                if (skip > 0)
                {
                    skip--;
                    continue;
                }

                if (ShouldIncludeItem(item))
                {
                    loadedItems.Add(item);
                    var id = GetItemId(item);
                    if (!string.IsNullOrEmpty(id))
                    {
                        loadedItemIds.Add(id);
                    }
                }

                if (loadedItems.Count >= PageSize)
                {
                    break;
                }
            }

            items.AddRange(loadedItems);
            hasMore = loadedItems.Count >= PageSize;

            if (OnItemsLoaded.HasDelegate)
            {
                await OnItemsLoaded.InvokeAsync(loadedItems);
            }
        }
        catch (Exception ex)
        {
            error = $"Failed to load more items: {ex.Message}";
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private async ValueTask<ItemsProviderResult<TItem>> LoadItemsAsync(ItemsProviderRequest request)
    {
        try
        {
            var loadedItems = new List<TItem>();
            var skip = request.StartIndex;

            await foreach (var item in Client.GetCollectionAsync<TItem>(CollectionUrl!, null))
            {
                if (skip > 0)
                {
                    skip--;
                    continue;
                }

                loadedItems.Add(item);
                if (loadedItems.Count >= request.Count)
                {
                    break;
                }
            }

            return new ItemsProviderResult<TItem>(loadedItems, loadedItems.Count);
        }
        catch (Exception ex)
        {
            error = $"Failed to load items: {ex.Message}";
            return new ItemsProviderResult<TItem>(Array.Empty<TItem>(), 0);
        }
    }

    /// <summary>
    /// Refreshes the collection from the beginning.
    /// </summary>
    public async Task RefreshAsync()
    {
        // Clear cache for this collection
        if (EnableCaching && CollectionUrl != null)
        {
            cache.Remove(CollectionUrl.ToString());
        }

        items.Clear();
        loadedItemIds.Clear();
        hasMore = true;
        error = null;

        if (UseVirtualization && virtualizeComponent != null)
        {
            await virtualizeComponent.RefreshDataAsync();
        }
        else
        {
            await LoadInitialItemsAsync();
        }
    }

    /// <summary>
    /// Clears all cached collections.
    /// </summary>
    public void ClearCache()
    {
        cache.Clear();
    }

    /// <summary>
    /// Gets the current loaded items.
    /// </summary>
    public IReadOnlyList<TItem> GetItems() => items.AsReadOnly();

    /// <summary>
    /// Gets whether the component is currently loading.
    /// </summary>
    public bool IsLoading => isLoading;

    public void Dispose()
    {
        loadCancellation?.Cancel();
        loadCancellation?.Dispose();
    }
}
