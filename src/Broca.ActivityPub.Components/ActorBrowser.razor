@using Broca.ActivityPub.Core.Interfaces
@using KristofferStrube.ActivityStreams
@inject IActivityPubClient Client

<div class="activitypub-actor-browser @CssClass">
    @if (SearchTemplate != null)
    {
        <div class="actor-search">
            @SearchTemplate(new SearchContext(this))
        </div>
    }
    else
    {
        <div class="actor-search-default">
            <input type="text" 
                   @bind="searchQuery" 
                   @bind:event="oninput"
                   placeholder="Enter actor handle (e.g., user@domain.com)" 
                   class="search-input" />
            <button @onclick="SearchAsync" class="search-button">Search</button>
        </div>
    }

    @if (isLoading)
    {
        @if (LoadingTemplate != null)
        {
            @LoadingTemplate
        }
        else
        {
            <div class="loading">Searching...</div>
        }
    }
    else if (error != null)
    {
        @if (ErrorTemplate != null)
        {
            @ErrorTemplate(error)
        }
        else
        {
            <div class="error">@error</div>
        }
    }
    else if (currentActor != null)
    {
        <div class="actor-result">
            @if (ProfileTemplate != null)
            {
                @ProfileTemplate(currentActor)
            }
            else
            {
                <ActorRenderer Actor="currentActor" />
            }
        </div>
    }
</div>

@code {
    private string searchQuery = string.Empty;
    private KristofferStrube.ActivityStreams.Object? currentActor;
    private bool isLoading;
    private string? error;
    private List<string> searchHistory = new();
    private const int MaxHistorySize = 10;

    /// <summary>
    /// Gets or sets the CSS class for the container.
    /// </summary>
    [Parameter]
    public string? CssClass { get; set; }

    /// <summary>
    /// Gets or sets whether to show search history.
    /// </summary>
    [Parameter]
    public bool ShowSearchHistory { get; set; } = true;

    /// <summary>
    /// Gets or sets whether to enable WebFinger lookup.
    /// </summary>
    [Parameter]
    public bool EnableWebFinger { get; set; } = true;

    /// <summary>
    /// Gets or sets the search input template.
    /// </summary>
    [Parameter]
    public RenderFragment<SearchContext>? SearchTemplate { get; set; }

    /// <summary>
    /// Gets or sets the profile display template.
    /// </summary>
    [Parameter]
    public RenderFragment<KristofferStrube.ActivityStreams.Object>? ProfileTemplate { get; set; }

    /// <summary>
    /// Gets or sets the loading template.
    /// </summary>
    [Parameter]
    public RenderFragment? LoadingTemplate { get; set; }

    /// <summary>
    /// Gets or sets the error template.
    /// </summary>
    [Parameter]
    public RenderFragment<string>? ErrorTemplate { get; set; }

    /// <summary>
    /// Gets or sets a callback for when an actor is found.
    /// </summary>
    [Parameter]
    public EventCallback<KristofferStrube.ActivityStreams.Object> OnActorFound { get; set; }

    /// <summary>
    /// Searches for an actor by handle or ID.
    /// </summary>
    public async Task SearchAsync()
    {
        if (string.IsNullOrWhiteSpace(searchQuery))
        {
            error = "Please enter an actor handle or ID";
            return;
        }

        isLoading = true;
        error = null;
        currentActor = null;
        StateHasChanged();

        try
        {
            // Try WebFinger lookup first if enabled and looks like a handle
            if (EnableWebFinger && searchQuery.Contains('@') && !searchQuery.StartsWith("http"))
            {
                currentActor = await ResolveViaWebFingerAsync(searchQuery);
            }
            // Try direct URI lookup
            else if (Uri.TryCreate(searchQuery, UriKind.Absolute, out var actorUri))
            {
                currentActor = await Client.GetActorAsync(actorUri);
            }
            // Try as an alias/handle
            else
            {
                currentActor = await Client.GetActorByAliasAsync(searchQuery);
            }

            if (currentActor != null)
            {
                AddToHistory(searchQuery);

                if (OnActorFound.HasDelegate)
                {
                    await OnActorFound.InvokeAsync(currentActor);
                }
            }
            else
            {
                error = "Actor not found";
            }
        }
        catch (Exception ex)
        {
            error = $"Failed to find actor: {ex.Message}";
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private async Task<KristofferStrube.ActivityStreams.Object?> ResolveViaWebFingerAsync(string handle)
    {
        try
        {
            // WebFinger implementation
            // Format: user@domain.com
            var parts = handle.Split('@', StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length != 2)
            {
                throw new FormatException("Invalid handle format. Expected user@domain");
            }

            var user = parts[0];
            var domain = parts[1];
            var webFingerUrl = $"https://{domain}/.well-known/webfinger?resource=acct:{user}@{domain}";
            
            // Make WebFinger request to get actor URL
            using var httpClient = new HttpClient();
            httpClient.DefaultRequestHeaders.Add("Accept", "application/jrd+json");
            
            var response = await httpClient.GetStringAsync(webFingerUrl);
            
            // Parse WebFinger response to extract actor URL
            // This is a simplified implementation
            // You may want to use a JSON parser for more robust handling
            var actorUrlMatch = System.Text.RegularExpressions.Regex.Match(
                response, 
                @"""href""\s*:\s*""([^""]+)""[^}]*""type""\s*:\s*""application/activity\+json"""
            );
            
            if (actorUrlMatch.Success && Uri.TryCreate(actorUrlMatch.Groups[1].Value, UriKind.Absolute, out var actorUri))
            {
                return await Client.GetActorAsync(actorUri);
            }
            
            throw new Exception("Could not extract actor URL from WebFinger response");
        }
        catch (Exception ex)
        {
            // Fall back to direct lookup
            throw new Exception($"WebFinger lookup failed: {ex.Message}", ex);
        }
    }

    private void AddToHistory(string query)
    {
        if (!string.IsNullOrWhiteSpace(query))
        {
            searchHistory.Remove(query); // Remove if already exists
            searchHistory.Insert(0, query);
            
            // Keep only the most recent items
            if (searchHistory.Count > MaxHistorySize)
            {
                searchHistory.RemoveRange(MaxHistorySize, searchHistory.Count - MaxHistorySize);
            }
        }
    }

    /// <summary>
    /// Searches from history.
    /// </summary>
    public async Task SearchFromHistoryAsync(string query)
    {
        searchQuery = query;
        await SearchAsync();
    }

    /// <summary>
    /// Clears the search history.
    /// </summary>
    public void ClearHistory()
    {
        searchHistory.Clear();
        StateHasChanged();
    }

    /// <summary>
    /// Search context provided to the search template.
    /// </summary>
    public class SearchContext
    {
        private readonly ActorBrowser _browser;

        public SearchContext(ActorBrowser browser)
        {
            _browser = browser;
        }

        /// <summary>
        /// Gets or sets the current query.
        /// </summary>
        public string Query
        {
            get => _browser.searchQuery;
            set => _browser.searchQuery = value;
        }

        /// <summary>
        /// Executes the search.
        /// </summary>
        public Task Execute() => _browser.SearchAsync();

        /// <summary>
        /// Gets whether a search is in progress.
        /// </summary>
        public bool IsLoading => _browser.isLoading;
    }
}
